# exgcd

请修改 `exgcd.py`，实现欧几里得算法和扩展欧几里得算法。

## 欧几里得算法

### 原理

记两非负整数 a 和 b 的最大公因数为 `gcd(a,b)`，我们知道，最大公因数满足下面的性质：

```text
gcd(a, b) = gcd(b, a mod b)
```

其中 `mod` 指的是取余的操作，这个方法可以一直做下去，直到最后取余等于零位置。这个算法就是欧几里得算法，也叫辗转相除法。

### 例子

让我们来看一个例子：

```text
(32, 48)
= (48, 32)
= (32, 16)
= (16, 0)
= 16
```

### 代码

我们需要修改 `exgcd.py` 中的 `gcd` 函数，用 Python 代码来实现以上的欧几里得算法：

```python
def gcd(a, b):
	# TODO: Euclidean algorithm
```

函数的返回值就是一个整数，即 a 和 b 的最大公约数。

根据上面的公式，按照下面的思路来实现：

1. 判断 b 是否为零，此时最大公约数就是 a，直接返回
2. 如果 a 和 b 都不为零，那么按照公式进行递归

由于本作业的目的是考察递归函数的编写，因此你需要使用递归来实现，使用其他方法可能会损失白盒分数。

## 扩展欧几里得算法

### 原理

本题的第二部分是实现扩展欧几里得算法。根据裴蜀定理，一定存在整数 x 和 y 满足：

```text
a*x + b*y = gcd(a, b)
```

而扩展欧几里得算法可以根据 a 和 b，计算出最大公约数 `gcd(a, b)` 以及上面的系数 x 和 y。

它的原理如下：

首先，根据最大公因数的公式，有：

```text
gcd(a, b) = gcd(b, a mod b)
```

我们要寻找 x 和 y 满足 `a*x + b*y = gcd(a, b)`，那么可以首先寻找一组更小的解，然后再求出 x 和 y。

假设我们经过递归，已经求出了 x0 和 y0，满足：

```text
b*x0 + (a mob b)*y0 = gcd(b, a mod b)
```

可以看到，这里的 x0 和 y0 就是对于 b 和 `a mod b` 这两个数的解。

一直递归下去，一定会有一个时候，出现 `b=0`，此时 `gcd(a, b) = a`，那么 `a*1 + b*0 = a`，此时 `x=1, y=0`。

接下来，我们考虑如何从递归后的 x0 和 y0 计算出原来的 x 和 y。回忆一下条件：

```text
a*x + b*y = gcd(a, b)
b*x0 + (a mod b)*y0 = gcd(b, a mod b)
gcd(a, b) = gcd(b, a mod b)
a = (a mod b) + floor(a / b) * b
```

其中 floor 是向下取整的意思（Python 中的 `//` 运算符），最后一行的意思是，a 可以分为可以整除 b 的部分和余数两个部分。

求解上面的方程：

```text
a*x + b*y = b*x0 + (a mod b)*y0
a*x + b*(y - x0) = (a - floor(a / b) * b)*y0
a*(x - y0) + b*(y - x0 + floor(a / b) * y0) = 0
```

根据 a 和 b 的任意性，可得：

```
x = y0
y = x0 - floor(a / b) * y0
```

这样，我们就可以根据递归结果，得到满足 `a*x + b*y = gcd(a, b)` 的解。

### 例子

下面来看一个例子：

已知 a=48, b=32，求 x 和 y 使得 `48x + 32y = gcd(48, 32)`。

首先还是按照辗转相除法进行递归：

```
gcd(48, 32)
= gcd(32, 16)
= gcd(16, 0)
= 16
```

那么最后一步的时候，a=16, b=0, x0=1, y0=0, 满足 `16*1 + 0*0 = 16`。

接下来，求倒数第二步的系数，此时：

```
a = 32
b = 16
x1 = y0 = 0
y1 = x0 - floor(32 / 16) * y0 = 1
a*x1 + b*y1 = 16
```

再求第一步的系数，此时：

```
a = 48
b = 32
x2 = y1 = 1
y2 = x1 - floor(48 / 32) * y1 = -1
a*x2 + b*y2 = 16
```

此时已经完成了扩展欧几里得算法的实现，答案就是 `x=1, y=-1, gcd(a,b)=16`。

### 代码

我们需要修改 `exgcd.py` 中的 `exgcd` 函数，用 Python 代码来实现以上的扩展欧几里得算法：

```python
def exgcd(a, b):
	# TODO: Extended Euclidean algorithm
```

函数的返回值是一个三元组：(x, y, g)，满足 `a*x + b*y = gcd(a, b) = g`

根据上面的公式，按照下面的思路来实现：

1. 判断 b 是否为零，此时最大公约数就是 a，x=1, y=0，直接返回
2. 如果 a 和 b 都不为零，那么按照公式进行递归；递归返回后，根据公式计算 x 和 y

由于本作业的目的是考察递归函数的编写，因此你需要使用递归来实现，使用其他方法可能会损失白盒分数。

由于 x 和 y 可能有无穷多组解，这里需要严格按照上面的算法实现，这样答案是唯一的。

## 输入格式

第一行是一个字符串，如果是 `gcd`，那么这一组数据要执行欧几里得算法；如果是 `exgcd`，那么这一组数据要执行扩展欧几里得算法。

下面有两行，每一行一个整数，分别是 a 和 b。

前三个测例是 gcd，后两个测例是 exgcd。

## 输出格式

如果是 gcd，输出一行，只有一个整数，即 a 和 b 的最大公约数。

如果是 exgcd，输出三行，每行一个整数，分别是 x，y 和最大公约数。

## 评分

你可以在本地当前目录下运行 `python3 grade.py` 来进行一次本地的评分，提交到 GitLab 后，CI 也会进行评分。

最终分数构成为：

* 黑盒 80 分：共 5 个测例，每个 16 分
* 白盒 20 分

从本作业开始，助教将对代码进行查重。同学在实现过程中，如果参考了网上的代码，或者和其他同学交流，请把相关的网址、同学姓名和交流内容写到 `HONOR-CODE.md` 文件中并提交。

助教以 deadline 前 <https://git.tsinghua.edu.cn/> 上最后一次提交为准进行评测。
